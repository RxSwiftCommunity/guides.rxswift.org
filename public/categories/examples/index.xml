<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Examples on RxSwift</title>
    <link>http://localhost:1313/categories/examples/</link>
    <description>Recent content in Examples on RxSwift</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 23 Oct 2015 17:38:00 +0200</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/examples/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Examples</title>
      <link>http://localhost:1313/examples/</link>
      <pubDate>Fri, 23 Oct 2015 17:38:00 +0200</pubDate>
      
      <guid>http://localhost:1313/examples/</guid>
      <description>

&lt;h2 id=&#34;calculated-variable:9ecc00cd7c4c5bc9e8febc4fe00186bf&#34;&gt;Calculated variable&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s first start with some imperative swift code.
The purpose of example is to bind identifier &lt;code&gt;c&lt;/code&gt; to a value calculated from &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; if some condition is satisfied.&lt;/p&gt;

&lt;p&gt;Here is the imperative swift code that calculates the value of &lt;code&gt;c&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// this is usual imperative code
var c: String
var a = 1       // this will only assign value `1` to `a` once
var b = 2       // this will only assign value `2` to `b` once

if a + b &amp;gt;= 0 {
    c = &amp;quot;\(a + b) is positive&amp;quot; // this will only assign value to `c` once
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The value of &lt;code&gt;c&lt;/code&gt; is now &lt;code&gt;3 is positive&lt;/code&gt;. But if we change the value of &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; will still contain the old value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;a = 4           // c will still be equal &amp;quot;3 is positive&amp;quot; which is not good
                // c should be equal to &amp;quot;6 is positive&amp;quot; because 4 + 2 = 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is not the wanted behavior.&lt;/p&gt;

&lt;p&gt;To integrate RxSwift framework into your project just include framework in your project and write &lt;code&gt;import RxSwit&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is the same logic using RxSwift.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let a /*: Observable&amp;lt;Int&amp;gt;*/ = Variable(1)   // a = 1
let b /*: Observable&amp;lt;Int&amp;gt;*/ = Variable(2)   // b = 2

// This will &amp;quot;bind&amp;quot; rx variable `c` to definition
// if a + b &amp;gt;= 0 {
//      c = &amp;quot;\(a + b) is positive&amp;quot;
// }
let c = combineLatest(a, b) { $0 + $1 }     // combines latest values of variables `a` and `b` using `+`
    .filter { $0 &amp;gt;= 0 }               // if `a + b &amp;gt;= 0` is true, `a + b` is passed to map operator
    .map { &amp;quot;\($0) is positive&amp;quot; }      // maps `a + b` to &amp;quot;\(a + b) is positive&amp;quot;

// Since initial values are a = 1, b = 2
// 1 + 2 = 3 which is &amp;gt;= 0, `c` is intially equal to &amp;quot;3 is positive&amp;quot;

// To pull values out of rx variable `c`, subscribe to values from  `c`.
// `subscribeNext` means subscribe to next (fresh) values of variable `c`.
// That also includes the inital value &amp;quot;3 is positive&amp;quot;.
c.subscribeNext { print($0) }          // prints: &amp;quot;3 is positive&amp;quot;

// Now let&#39;s increase the value of `a`
// a = 4 is in RxSwift
a.next(4)                                   // prints: 6 is positive
// Sum of latest values is now `4 + 2`, `6` is &amp;gt;= 0, map operator
// produces &amp;quot;6 is positive&amp;quot; and that result is &amp;quot;assigned&amp;quot; to `c`.
// Since the value of `c` changed, `{ print($0) }` will get called,
// and &amp;quot;6 is positive&amp;quot; is printed.

// Now let&#39;s change the value of `b`
// b = -8 is in RxSwift
b.next(-8)                                  // doesn&#39;t print anything
// Sum of latest values is `4 + (-8)`, `-4` is not &amp;gt;= 0, map doesn&#39;t
// get executed.
// That means that `c` still contains &amp;quot;6 is positive&amp;quot; and that&#39;s correct.
// Since `c` hasn&#39;t been updated, that means next value hasn&#39;t been produced,
// and `{ print($0) }` won&#39;t be called.

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;simple-ui-bindings:9ecc00cd7c4c5bc9e8febc4fe00186bf&#34;&gt;Simple UI bindings&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;instead of binding to variables, let&amp;rsquo;s bind to text field values (rx_text)&lt;/li&gt;
&lt;li&gt;next, parse that into an int and calculate if the number is prime using an async API (map)&lt;/li&gt;
&lt;li&gt;if text field value is changed before async call completes, new async call will be enqueued (concat)&lt;/li&gt;
&lt;li&gt;bind results to label (resultLabel.rx_subscribeTextTo)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let subscription/*: Disposable */ = primeTextField.rx_text      // type is Observable&amp;lt;String&amp;gt;
            .map { WolframAlphaIsPrime($0.toInt() ?? 0) }       // type is Observable&amp;lt;Observable&amp;lt;Prime&amp;gt;&amp;gt;
            .concat()                                           // type is Observable&amp;lt;Prime&amp;gt;
            .map { &amp;quot;number \($0.n) is prime? \($0.isPrime)&amp;quot; }   // type is Observable&amp;lt;String&amp;gt;
            .bindTo(resultLabel.rx_text)                        // return Disposable that can be used to unbind everything

// This will set resultLabel.text to &amp;quot;number 43 is prime? true&amp;quot; after
// server call completes.
primeTextField.text = &amp;quot;43&amp;quot;

// ...

// to unbind everything, just call
subscription.dispose()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All of the operators used in this example are the same operators used in the first example with variables. Nothing special about it.&lt;/p&gt;

&lt;h2 id=&#34;autocomplete:9ecc00cd7c4c5bc9e8febc4fe00186bf&#34;&gt;Autocomplete&lt;/h2&gt;

&lt;p&gt;If you are new to Rx, next example will probably be a little overwhelming, but it&amp;rsquo;s here to demonstrate how RxSwift code looks like in real world examples.&lt;/p&gt;

&lt;p&gt;The third example is a real world, complex UI async validation logic, with progress notifications.
All operations are cancelled the moment &lt;code&gt;disposeBag&lt;/code&gt; is deallocated.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s give it a shot.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// bind UI control values directly
// use username from `usernameOutlet` as username values source
self.usernameOutlet.rx_text
    .map { username in

        // synchronous validation, nothing special here
        if count(username) == 0 {
            // Convenience for constructing synchronous result.
            // In case there is mixed synchronous and asychronous code inside the same
            // method, this will construct an async result that is resolved immediatelly.
            return returnElement((valid: false, message: &amp;quot;Username can&#39;t be empty.&amp;quot;))
        }

        ...

        // Every user interface probably shows some state while async operation
        // is executing.
        // Let&#39;s assume that we want to show &amp;quot;Checking availability&amp;quot; while waiting for result.
        // valid parameter can be
        //  * true  - is valid
        //  * false - not valid
        //  * nil   - validation pending
        let loadingValue = (valid: nil, message: &amp;quot;Checking availability ...&amp;quot;)

        // This will fire a server call to check if the username already exists.
        // Guess what, its type is `Observable&amp;lt;ValidationResult&amp;gt;`
        return API.usernameAvailable(username)
          .map { available in
              if available {
                  return (true, &amp;quot;Username available&amp;quot;)
              }
              else {
                  return (false, &amp;quot;Username already taken&amp;quot;)
              }
          }
          // use `loadingValue` until server responds
          .startWith(loadingValue)
    }
// Since we now have `Observable&amp;lt;Observable&amp;lt;ValidationResult&amp;gt;&amp;gt;`
// we somehow need to return to normal `Observable` world.
// We could use `concat` operator from second example, but we really
// want to cancel pending asynchronous operation if new username is
// provided.
// That&#39;s what `switchLatest` does
    .switchLatest()
// Now we need to bind that to the user interface somehow.
// Good old `subscribeNext` can do that
// That&#39;s the end of `Observable` chain.
// This will produce a `Disposable` object that can unbind everything and cancel
// pending async operations.
    .subscribeNext { valid in
        errorLabel.textColor = validationColor(valid)
        errorLabel.text = valid.message
    }
// Why would we do it manually, that&#39;s tedious,
// let&#39;s dispose everything automagically on view controller dealloc.
    .addDisposableTo(disposeBag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Can&amp;rsquo;t get any simpler than this. There are &lt;a href=&#34;../RxExample&#34;&gt;more examples&lt;/a&gt; in the repository, so feel free to check them out.&lt;/p&gt;

&lt;p&gt;They include examples on how to use it in the context of MVVM pattern or without it.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>